"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
/**
 * Class for wrapping a socket (TCP, Websocket or Virtual) under a common interface.
 *
 * Socket specific functions need to be overridden/implemented in dervived classes.
 */
class Client {
    constructor(clientOptions) {
        /**
         * Base close event procedure responsible for triggering the close event.
         */
        this.socketClosed = (hadError) => {
            this.isClosed = true;
            this.triggerEvent("close", hadError);
        };
        /**
         * Base data event procedure responsible for triggering the data event.
         *
         * @param {Buffer} data - data buffer.
         *
         */
        this.socketData = (data) => {
            var _a;
            if (!(data instanceof Buffer)) {
                throw "Must read buffer.";
            }
            const bufferData = ((_a = this.clientOptions) === null || _a === void 0 ? void 0 : _a.bufferData) === undefined ? true : this.clientOptions.bufferData;
            this.triggerEvent("data", data, bufferData);
        };
        /**
         * Base connect event procedure responsible for triggering the connect event.
         */
        this.socketConnected = () => {
            this.triggerEvent("connect");
        };
        /**
         * Base error event procedure responsible for triggering the error event.
         *
         * @param {Buffer} data - error message.
         *
         */
        this.socketError = (message) => {
            this.triggerEvent("error", message);
        };
        this.clientOptions = clientOptions;
        this.eventHandlers = {};
        this.isClosed = false;
    }
    /**
     * Connect to server.
     *
     */
    connect() {
        this.socketConnect();
        this.socketHook();
    }
    /**
     * Send string on socket.
     *
     */
    sendString(data) {
        this.send(Buffer.from(data));
    }
    /**
     * Send buffer on socket.
     *
     * @param {Buffer} data to be sent
     * @throws An error will be thrown when buffer data type is incompatible.
     */
    send(data) {
        if (this.isClosed) {
            return;
        }
        if (!(data instanceof Buffer)) {
            throw "Data must be of Buffer type.";
        }
        this.socketSend(data);
    }
    /**
     * Close socket.
     */
    close() {
        if (this.isClosed) {
            return;
        }
        this.socketClose();
    }
    /**
     * User hook for socket errors.
     *
     * @param {Function} fn - on error callback. Function is passed a Buffer object with the error message
     *
     */
    onError(fn) {
        this.on("error", fn);
    }
    /**
     * Unhook handler for socket errors.
     *
     * @param {Function} fn - remove existing error callback
     *
     */
    offError(fn) {
        this.off("error", fn);
    }
    /**
     * User hook for incoming data.
     *
     * @param {Function} fn - on data callback. Function is passed a Buffer object.
     */
    onData(fn) {
        this.on("data", fn);
    }
    /**
     * Unhook handler for incoming data.
     *
     * @param {Function} fn - remove data callback.
     *
     */
    offData(fn) {
        this.off("data", fn);
    }
    /**
     * User hook for connection event.
     *
     * @param {Function} fn - on connect callback.
     *
     */
    onConnect(fn) {
        this.on("connect", fn);
    }
    /**
     * Unhook handler for connection event.
     *
     * @param {Function} fn - remove connect callback.
     *
     */
    offConnect(fn) {
        this.off("connect", fn);
    }
    /**
     * User hook for close event.
     *
     * @param {Function} fn - on close callback.
     *
     */
    onClose(fn) {
        this.on("close", fn);
    }
    /**
     * Unhook handler for close event.
     *
     * @param {Function} fn - remove close callback.
     *
     */
    offClose(fn) {
        this.off("close", fn);
    }
    getLocalAddress() {
        // Override in implementation if applicable
        return undefined;
    }
    getRemoteAddress() {
        // Override in implementation if applicable
        return undefined;
    }
    getRemotePort() {
        // Override in implementation if applicable
        return undefined;
    }
    getLocalPort() {
        // Override in implementation if applicable
        return undefined;
    }
    /**
     * Unread data by putting it back into the event queue.
     * @param {Buffer} data
     */
    unRead(data) {
        var _a;
        const bufferData = ((_a = this.clientOptions) === null || _a === void 0 ? void 0 : _a.bufferData) === undefined ? true : this.clientOptions.bufferData;
        this.triggerEvent("data", data, bufferData, true);
    }
    /**
     * Create the socket object and initiate a connection.
     * This only done for initiating client sockets.
     * A server listener socket client is already connected and must be passed in the constructor.
     */
    socketConnect() {
        throw "Function not implemented.";
    }
    /**
     * Hook events on the socket.
     */
    socketHook() {
        throw "Function not implemented.";
    }
    /**
     * Send the given buffer on socket.
     * Socket specific implementation.
     */
    socketSend(buffer) {
        throw "Function not implemented.";
    }
    /**
     * Socket-specific close procedure.
     */
    socketClose() {
        throw "Function not implemented.";
    }
    /**
     * Base "off" event procedure responsible for removing a callback from the list of event handlers.
     *
     * @param {string} event - event name.
     * @param {Function} fn - callback.
     *
     */
    off(event, fn) {
        const [fns, queue] = (this.eventHandlers[event] || [[], []]);
        const index = fns.indexOf(fn);
        if (index > -1) {
            fns.splice(index, 1);
        }
    }
    /**
     * Base "on" event procedure responsible for adding a callback to the list of event handlers.
     *
     * @param {string} event - event name.
     * @param {Function} fn - callback.
     *
     */
    on(event, fn) {
        const tuple = (this.eventHandlers[event] || [[], []]);
        this.eventHandlers[event] = tuple;
        const [fns, queue] = tuple;
        if (fns.length === 0) {
            // Send buffered up events.
            queue.forEach((event) => {
                fn(event);
            });
            queue.length = 0;
        }
        fns.push(fn);
    }
    /**
     * Trigger event calls the appropriate handler based on the event name.
     *
     * @param {string} event - event name.
     * @param {Buffer} [data] - event data.
     * @param {boolean} [doBuffer] - buffers up event data.
     * @param {boolean} [invertOrder] - used for "unreading" an event and puts it first in the queue (if doBuffer is true)
     *
     */
    triggerEvent(event, data, doBuffer = false, invertOrder = false) {
        const tuple = (this.eventHandlers[event] || [[], []]);
        this.eventHandlers[event] = tuple;
        const [fns, queue] = tuple;
        if (fns.length === 0) {
            if (doBuffer) {
                // Buffer up the event
                if (invertOrder) {
                    queue.unshift(data);
                }
                else {
                    queue.push(data);
                }
            }
        }
        else {
            fns.forEach((fn) => {
                fn(data);
            });
        }
    }
}
exports.Client = Client;
