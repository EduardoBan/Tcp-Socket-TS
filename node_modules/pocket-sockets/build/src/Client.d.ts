/// <reference types="node" />
import { ClientOptions } from "./types";
/**
 * Class for wrapping a socket (TCP, Websocket or Virtual) under a common interface.
 *
 * Socket specific functions need to be overridden/implemented in dervived classes.
 */
export declare abstract class Client {
    clientOptions?: ClientOptions;
    eventHandlers: {
        [key: string]: [Function[], (Buffer | undefined)[]];
    };
    isClosed: boolean;
    constructor(clientOptions: ClientOptions);
    /**
     * Connect to server.
     *
     */
    connect(): void;
    /**
     * Send string on socket.
     *
     */
    sendString(data: string): void;
    /**
     * Send buffer on socket.
     *
     * @param {Buffer} data to be sent
     * @throws An error will be thrown when buffer data type is incompatible.
     */
    send(data: Buffer): void;
    /**
     * Close socket.
     */
    close(): void;
    /**
     * User hook for socket errors.
     *
     * @param {Function} fn - on error callback. Function is passed a Buffer object with the error message
     *
     */
    onError(fn: Function): void;
    /**
     * Unhook handler for socket errors.
     *
     * @param {Function} fn - remove existing error callback
     *
     */
    offError(fn: Function): void;
    /**
     * User hook for incoming data.
     *
     * @param {Function} fn - on data callback. Function is passed a Buffer object.
     */
    onData(fn: Function): void;
    /**
     * Unhook handler for incoming data.
     *
     * @param {Function} fn - remove data callback.
     *
     */
    offData(fn: Function): void;
    /**
     * User hook for connection event.
     *
     * @param {Function} fn - on connect callback.
     *
     */
    onConnect(fn: Function): void;
    /**
     * Unhook handler for connection event.
     *
     * @param {Function} fn - remove connect callback.
     *
     */
    offConnect(fn: Function): void;
    /**
     * User hook for close event.
     *
     * @param {Function} fn - on close callback.
     *
     */
    onClose(fn: Function): void;
    /**
     * Unhook handler for close event.
     *
     * @param {Function} fn - remove close callback.
     *
     */
    offClose(fn: Function): void;
    getLocalAddress(): string | undefined;
    getRemoteAddress(): string | undefined;
    getRemotePort(): number | undefined;
    getLocalPort(): number | undefined;
    /**
     * Unread data by putting it back into the event queue.
     * @param {Buffer} data
     */
    unRead(data: Buffer): void;
    /**
     * Create the socket object and initiate a connection.
     * This only done for initiating client sockets.
     * A server listener socket client is already connected and must be passed in the constructor.
     */
    protected socketConnect(): void;
    /**
     * Hook events on the socket.
     */
    protected socketHook(): void;
    /**
     * Send the given buffer on socket.
     * Socket specific implementation.
     */
    protected socketSend(buffer: Buffer): void;
    /**
     * Socket-specific close procedure.
     */
    protected socketClose(): void;
    /**
     * Base close event procedure responsible for triggering the close event.
     */
    protected socketClosed: (hadError: boolean) => void;
    /**
     * Base data event procedure responsible for triggering the data event.
     *
     * @param {Buffer} data - data buffer.
     *
     */
    protected socketData: (data: Buffer) => void;
    /**
     * Base connect event procedure responsible for triggering the connect event.
     */
    protected socketConnected: () => void;
    /**
     * Base error event procedure responsible for triggering the error event.
     *
     * @param {Buffer} data - error message.
     *
     */
    protected socketError: (message: Buffer) => void;
    /**
     * Base "off" event procedure responsible for removing a callback from the list of event handlers.
     *
     * @param {string} event - event name.
     * @param {Function} fn - callback.
     *
     */
    private off;
    /**
     * Base "on" event procedure responsible for adding a callback to the list of event handlers.
     *
     * @param {string} event - event name.
     * @param {Function} fn - callback.
     *
     */
    private on;
    /**
     * Trigger event calls the appropriate handler based on the event name.
     *
     * @param {string} event - event name.
     * @param {Buffer} [data] - event data.
     * @param {boolean} [doBuffer] - buffers up event data.
     * @param {boolean} [invertOrder] - used for "unreading" an event and puts it first in the queue (if doBuffer is true)
     *
     */
    private triggerEvent;
}
