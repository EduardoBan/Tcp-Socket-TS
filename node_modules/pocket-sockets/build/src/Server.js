"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Server = void 0;
/**
 * Boilerplate for creating and wrapping a server socket listener (TCP or Websocket) under a common interface.
 *
 * Socket specific functions need to be overridden/implemented.
 *
 */
class Server {
    constructor(serverOptions) {
        /**
         * Internal error event implementation.
         *
         * @param {Error} err
         */
        this.serverError = (err) => {
            this.triggerEvent("error", (err && err.message) ? err.message : err);
        };
        /**
         * Internal close event implementation.
         */
        this.serverClosed = () => {
            this.isClosed = true;
            this.triggerEvent("close");
        };
        this.serverOptions = serverOptions;
        this.eventHandlers = {};
        this.clients = [];
        this.isClosed = false;
    }
    /**
     * Listens for connections and yields connected client sockets.
     *
     */
    listen() {
        this.serverListen();
    }
    /**
     * Close listener and all accepted socket clients.
     */
    close() {
        if (this.isClosed) {
            return;
        }
        this.serverClose();
        this.clients.forEach(client => client.close());
        this.clients = [];
    }
    /**
     * Event handler triggered when client has connected.
     *
     * A Client object is passed as argument to fn() of the instance type this.SocketClass.
     *
     * @param {Function} fn callback
     */
    onConnection(fn) {
        this.on("connection", fn);
    }
    /**
     * Event handler triggered when a server error occurs.
     *
     * An error object is passed as argument to fn().
     *
     * @param {Function} fn callback
     */
    onError(fn) {
        this.on("error", fn);
    }
    /**
     * Event handler triggered when server has closed together with all its client sockets.
     *
     * @param {Function} fn callback
     */
    onClose(fn) {
        this.on("close", fn);
    }
    /**
     * Create the server socket.
     */
    serverCreate() {
        throw "Not implemented.";
    }
    /**
     * Initiate the server listener.
     */
    serverListen() {
        throw "Not implemented.";
    }
    /**
     * Close the server.
     * Override as necessary.
     */
    serverClose() {
        throw "Not implemented.";
    }
    /**
     * Performs all operations involved in registering a new client connection.
     *
     * @param {Client} client
     */
    addClient(client) {
        this.clients.push(client);
        client.onClose(() => { this.removeClient(client); });
        this.triggerEvent("connection", client);
    }
    /**
     * Performs all operations involved in removing an existing client registration.
     *
     * @param {Client} client
     */
    removeClient(client) {
        const index = this.clients.indexOf(client);
        if (index > -1) {
            this.clients.splice(index, 1);
        }
    }
    /**
     * Internal event implementation.
     *
     * @param {string} event
     * @param {Function} fn
     */
    on(event, fn) {
        const fns = this.eventHandlers[event] || [];
        this.eventHandlers[event] = fns;
        fns.push(fn);
    }
    /**
     * Internal event trigger implementation.
     *
     * @param {string} event
     * @param {any} data
     */
    triggerEvent(event, data) {
        const fns = this.eventHandlers[event] || [];
        fns.forEach(fn => {
            fn(data);
        });
    }
}
exports.Server = Server;
